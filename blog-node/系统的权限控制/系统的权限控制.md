---
title: 系统的权限控制
---

[TOC]

1. 需要理清是什么以及其内部的原理；
2. 为什么，各有什么优缺点；

## 权限控制

在很多应用中，我们都**需要向服务端提供自己的身份凭证来获得访问一些非公开资源的授权**。比如在一个博客平台，我们要修改自己的博客，那么服务端要求我们能够证明 “我是我” ，才会允许我们修改自己的博客。

## 权限设计

## Cookie-Session，cookie 存储 sessionId 来保证会话期间保持登陆

### Cookie

有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了**辨别用户身份**，**进行 Session 跟踪**而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息。

Cookie 的重要特性：

1. 小：最大不超过 4kb 的小型文本文件；
2. 保存在客户端：这既是优点又是缺点；
3. cookie 是属于某个域的：不能跨域访问。

### Session

在计算机中，尤其是在网络应用中，称为“会话控制”。**Session 对象存储特定用户会话所需的属性及配置信息**。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。

#### 使用 session 授权

利用 session 来验证用户，有两种机制实现：

1. 需要服务端在**用户登录成功后生成一个 session ID 保存在服务端**，这个 session ID 标识当前会话的用户，以后用户的**每一次请求中都会包含 session ID**，服务端可以识别这个 session ID 验证用户身份然后才会授权。服务端用这个 session ID 来映射到对应的 session 数据。
2. 把 session ID 和其他数据加密后**发给用户，由用户来存储并在以后每次请求中发给服务端来验证。**比如**可以用 cookie 存储发送**，也可以使用其他客户端存储。

总结：

1. **始终需要发送 session ID 到服务端的**，后端可以控制前端的 cookie。
2. 使用 cookie 也就意味把信息都存放在前端，这些信息不会保存在数据库；
3. 使用 session，也就是只把 session ID 发给前端，然后每次请求的时候带上，这个时候用户的登陆信息会保存到服务端数据库，通过 session ID 查询。

### session 验证方式的问题

1. 如果是**原生 app 使用这种服务接口，又因为没有浏览器 cookie 功能，所以接入会相对麻烦**。
2. CSRF 攻击一般基于 cookie。

## 单点登陆，一点登陆多点共享登陆信息

1. **对内的统一登录**：如果我们在`http://login.taobao.com`登录成功了，我们在`http://taobao.com`中自然就处于登录状态了，不是吗。**使用相同父域名的服务们，可以利用 cookie 的特性之--允许一个子域可以设置或获取其父域的 Cookie**。cookie 中保存的数据，不论是表明了用户信息的 JWT，还是简单的 Sessionid，这些都不重要，反正我们已经让所有服务都能得到。**记得给 cookie 设 HTTPOnly 属性来防止跨站脚本攻击**。
2. 对外则是另一种情况，显然 taobao 和 baidu 是不会共享 cookie 的，**当我们在 baidu 登录，却需要获取 taobao 的用户信息时，我们就可以使用 OAuth**。

## jwt/token

1. 首先来看看 JWT 的概念，**JWT 的 token 由 头部(head)、数据(payload)、签名(signature)** 3 个部分组成；
2. 其中头部（header）和数据（payload）经过 base64 编码后经过秘钥 secret 的签名，就生成了第三部分----签名(signature) ，最后将 base64 编码的 header 和 payload 以及 signature 这 3 个部分用圆点 . 连接起来就生成了最终的 token。

### 前端存储和发送 token 的方式有以下两种

1. 使用 Header.Authorization + localStorage 存储和发送 token；
   1. 这种方法可以避免 CSRF 攻击，因为**没有使用 cookie** ，在 cookie 中没有 token，而 CSRF 就是基于 cookie 来攻击的。
   2. 这种方法容易被 XSS 攻击，因为 **XSS 可以攻击 localStorage ，从中读取到 token**，如果 token 中的 head 和 payload 部分没有加密，那么攻击者只要将 head 和 payload 的 base64 形式解码出来就可以看到 head 和 payload 的明文了。
2. 使用 cookie 存储和发送 token；
   1. 在这种情况下，我们需要使用 httpOnly 来使客户端脚本无法访问到 cookie，才能保证 token 安全。
   2. jwt，相对于 session 的形式，**可以不需要服务端存储登陆信息**；

## OAuth 2.0，允许第三方登录授权

OAuth 2.0 提供了一个安全的用户**授权第三方系统获取本系统用户信息的手段**。至于第三方系统获取本系统用户信息之后怎么做，那不重要，反正有了这份用户信息，第三方系统自然能做用户的对应，并且完成登录工作。

### 举例 OAuth 2.0 的使用，看看用微信登录掘金的过程

1. 打开掘金，未登录状态，点击登录，掘金给我们弹出一个登录框，上面有微信、QQ 登录选项，我们选择微信登录；
2. 之后掘金会将我们**重定向到微信的登录页面**，这个页面给出一个二维码供我们扫描，扫描之后；
3. 我们打开微信，扫描微信给的二维码之后，微信询问我们是否同意掘金使用我们的微信账号信息，我们点击同意；
4. 掘金刚才重定向到微信的二维码页面，现在**我们同意掘金使用我们的微信账号信息之后，又重定向回掘金的页面**，同时我们可以看到现在掘金的页面上显示我们已经处于登录状态，所以我们已经完成了用微信登录掘金的过程。

基本上就是一个登陆信息共享的过程。

### OAuth 2.0 提供了 4 种角色

1. 资源服务器；
2. 资源的拥有者；
3. 客户端应用；
4. 认证服务器。

## 参考文章

[JWT、OAuth 2.0、session 用户授权实战](https://segmentfault.com/a/1190000019210466)，查看实例 [demo](./auth-demo)。

[什么是 cookie,token 和 session?它们之间有什么关系？](https://www.zhihu.com/question/353373715/answer/974583248)
